// Code generated by mockery. DO NOT EDIT.

package gojen

import (
	gojen "github.com/cirius-go/gojen"
	mock "github.com/stretchr/testify/mock"
)

// FileManager is an autogenerated mock type for the FileManager type
type FileManager struct {
	mock.Mock
}

type FileManager_Expecter struct {
	mock *mock.Mock
}

func (_m *FileManager) EXPECT() *FileManager_Expecter {
	return &FileManager_Expecter{mock: &_m.Mock}
}

// AppendContent provides a mock function with given fields: path, content
func (_m *FileManager) AppendContent(path string, content string) error {
	ret := _m.Called(path, content)

	if len(ret) == 0 {
		panic("no return value specified for AppendContent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(path, content)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileManager_AppendContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppendContent'
type FileManager_AppendContent_Call struct {
	*mock.Call
}

// AppendContent is a helper method to define mock.On call
//   - path string
//   - content string
func (_e *FileManager_Expecter) AppendContent(path interface{}, content interface{}) *FileManager_AppendContent_Call {
	return &FileManager_AppendContent_Call{Call: _e.mock.On("AppendContent", path, content)}
}

func (_c *FileManager_AppendContent_Call) Run(run func(path string, content string)) *FileManager_AppendContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *FileManager_AppendContent_Call) Return(_a0 error) *FileManager_AppendContent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileManager_AppendContent_Call) RunAndReturn(run func(string, string) error) *FileManager_AppendContent_Call {
	_c.Call.Return(run)
	return _c
}

// CreateFileIfNotExist provides a mock function with given fields: path, content
func (_m *FileManager) CreateFileIfNotExist(path string, content string) (bool, error) {
	ret := _m.Called(path, content)

	if len(ret) == 0 {
		panic("no return value specified for CreateFileIfNotExist")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (bool, error)); ok {
		return rf(path, content)
	}
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(path, content)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(path, content)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FileManager_CreateFileIfNotExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateFileIfNotExist'
type FileManager_CreateFileIfNotExist_Call struct {
	*mock.Call
}

// CreateFileIfNotExist is a helper method to define mock.On call
//   - path string
//   - content string
func (_e *FileManager_Expecter) CreateFileIfNotExist(path interface{}, content interface{}) *FileManager_CreateFileIfNotExist_Call {
	return &FileManager_CreateFileIfNotExist_Call{Call: _e.mock.On("CreateFileIfNotExist", path, content)}
}

func (_c *FileManager_CreateFileIfNotExist_Call) Run(run func(path string, content string)) *FileManager_CreateFileIfNotExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *FileManager_CreateFileIfNotExist_Call) Return(created bool, err error) *FileManager_CreateFileIfNotExist_Call {
	_c.Call.Return(created, err)
	return _c
}

func (_c *FileManager_CreateFileIfNotExist_Call) RunAndReturn(run func(string, string) (bool, error)) *FileManager_CreateFileIfNotExist_Call {
	_c.Call.Return(run)
	return _c
}

// FileExists provides a mock function with given fields: path
func (_m *FileManager) FileExists(path string) bool {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for FileExists")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FileManager_FileExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FileExists'
type FileManager_FileExists_Call struct {
	*mock.Call
}

// FileExists is a helper method to define mock.On call
//   - path string
func (_e *FileManager_Expecter) FileExists(path interface{}) *FileManager_FileExists_Call {
	return &FileManager_FileExists_Call{Call: _e.mock.On("FileExists", path)}
}

func (_c *FileManager_FileExists_Call) Run(run func(path string)) *FileManager_FileExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *FileManager_FileExists_Call) Return(_a0 bool) *FileManager_FileExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileManager_FileExists_Call) RunAndReturn(run func(string) bool) *FileManager_FileExists_Call {
	_c.Call.Return(run)
	return _c
}

// TruncWithContent provides a mock function with given fields: path, content
func (_m *FileManager) TruncWithContent(path string, content string) error {
	ret := _m.Called(path, content)

	if len(ret) == 0 {
		panic("no return value specified for TruncWithContent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(path, content)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileManager_TruncWithContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TruncWithContent'
type FileManager_TruncWithContent_Call struct {
	*mock.Call
}

// TruncWithContent is a helper method to define mock.On call
//   - path string
//   - content string
func (_e *FileManager_Expecter) TruncWithContent(path interface{}, content interface{}) *FileManager_TruncWithContent_Call {
	return &FileManager_TruncWithContent_Call{Call: _e.mock.On("TruncWithContent", path, content)}
}

func (_c *FileManager_TruncWithContent_Call) Run(run func(path string, content string)) *FileManager_TruncWithContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *FileManager_TruncWithContent_Call) Return(_a0 error) *FileManager_TruncWithContent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileManager_TruncWithContent_Call) RunAndReturn(run func(string, string) error) *FileManager_TruncWithContent_Call {
	_c.Call.Return(run)
	return _c
}

// WalkDir provides a mock function with given fields: dirPath, openFile, handler
func (_m *FileManager) WalkDir(dirPath string, openFile bool, handler func(*gojen.FileInfo) error) error {
	ret := _m.Called(dirPath, openFile, handler)

	if len(ret) == 0 {
		panic("no return value specified for WalkDir")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, bool, func(*gojen.FileInfo) error) error); ok {
		r0 = rf(dirPath, openFile, handler)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FileManager_WalkDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalkDir'
type FileManager_WalkDir_Call struct {
	*mock.Call
}

// WalkDir is a helper method to define mock.On call
//   - dirPath string
//   - openFile bool
//   - handler func(*gojen.FileInfo) error
func (_e *FileManager_Expecter) WalkDir(dirPath interface{}, openFile interface{}, handler interface{}) *FileManager_WalkDir_Call {
	return &FileManager_WalkDir_Call{Call: _e.mock.On("WalkDir", dirPath, openFile, handler)}
}

func (_c *FileManager_WalkDir_Call) Run(run func(dirPath string, openFile bool, handler func(*gojen.FileInfo) error)) *FileManager_WalkDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(bool), args[2].(func(*gojen.FileInfo) error))
	})
	return _c
}

func (_c *FileManager_WalkDir_Call) Return(_a0 error) *FileManager_WalkDir_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *FileManager_WalkDir_Call) RunAndReturn(run func(string, bool, func(*gojen.FileInfo) error) error) *FileManager_WalkDir_Call {
	_c.Call.Return(run)
	return _c
}

// NewFileManager creates a new instance of FileManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFileManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *FileManager {
	mock := &FileManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
